% The \documentclass command is the first command in a LaTeX file.
\documentclass{report}

\pagenumbering{arabic}

\usepackage{graphicx}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
\usepackage{enumitem}
%\usepackage{epstopdf}
%\usepackage{tikz}
\usepackage{amssymb}

\begin{document}

\subsection*{Eddie Davis}
\textbf{CS 573}\\
\textbf{10/16/2017}\\

\section*{HW2: Design Principles}

\begin{enumerate}
	\item Queue ADT specification with new, add, poll, peek, and isEmpty functions
	where $x$ is of generic type $G$ and $q$ is a queue of type $QUEUE[G]$.
	
	\begin{enumerate}
		\item Type: \textit{QUEUE[G]}, all queues of arbitrary type $G$.
		\item Functions:
		\begin{itemize}
			\item \texttt{new}: $\rightarrow QUEUE[G]$ \\
			$creator$ function
			\item \texttt{add}: $QUEUE[G] \times G \rightarrow QUEUE[G]$ \\
			$command$ function
			\item \texttt{poll}: $QUEUE[G] \rightarrowtail G$ \\
			$command$ function			
			\item \texttt{peek}: $QUEUE[G] \rightarrowtail G$ \\
    		$query$ function
			\item \texttt{isEmpty}: $QUEUE[G] \rightarrow BOOLEAN$ \\
    		$query$ function			
		\end{itemize}
		
		\item Axioms		
		$\forall x:G, q:QUEUE[G]$,
			\begin{enumerate}
				\item \texttt{poll}(\texttt{add}(\texttt{new}, $x$)) = $x$
				\item \texttt{peek}($q, x$) = \texttt{poll}($q, x$)
				\item \texttt{isEmpty}(\texttt{new}) = \texttt{true}
				\item \texttt{not isEmpty}(\texttt{add}($q, x$)) = \texttt{true}
        	\end{enumerate}		

		\item Preconditions		
		\begin{itemize}
			\item \texttt{poll}($q: QUEUE[G]$) \texttt{requires not isEmpty}($q$)
            \item \texttt{peek}($q: QUEUE[G]$) \texttt{requires not isEmpty}($q$)
		\end{itemize}
	\end{enumerate}

	\item Class Design (20 points. 10 points for each).
	
	\begin{enumerate}
		\item 
		The \texttt{ATM} class mixes business logic and networking. By implementing the \texttt{Runnable} interface, it is also mixes threading logic. Otherwise, 
		it provides a good abstraction, it is a noun with method names corresponding
		to the proper verbs describing its functionality, e.g., \texttt{switchOn},
		\texttt{switchOff}, \texttt{performStartup}, and \texttt{performShutdown}. \\
		
		The \texttt{Money} class is also a good abstraction, however one does question
		whether it is necessary. Most of its methods involve mathematical
    	(\texttt{add}, \texttt{subtract}) or comparative (\texttt{lessEqual})
    	functions that could be supported by a standard library class such as \texttt{Long}. Only the \texttt{toString} method is money specific,
    	and could be supported by the \texttt{Locale} class. \\
    	
    	Similarly, the \texttt{Card} class could easily be replaced by an
    	integer primitive \texttt{int}. However, if other properties or methods
    	needed to be added, it would be a reasonable abstraction.
		
		\item The variables \texttt{ACCOUNT\_NUMBER}, \texttt{WITHDRAWALS\_TODAY}, \texttt{DAILY\_WINTHDRAWAL\_LIMIT}, and \texttt{BALANCE}
		in the \texttt{SimulatedBank} could be encapsulated into
		a single class called \texttt{SimulatedAccount} with
		attributes \texttt{number}, \texttt{withdrawalsToday},
		\texttt{dailyWithdrawalLimit}, and \texttt{balance}.
        The corresponding operations, such as \texttt{add} and
        \texttt{subtract} could be replaced with methods like
        \texttt{deposit} and \texttt{withdraw}. This abstraction
        would provide a clear separation of concerns and 
        application of object-oriented design principles.
	\end{enumerate}

	\item The command-query separation principle states that every method should either be a command that performs an action
	(mutator), or a query that returns data (accessor), but not both. The \texttt{ATM} class does \textbf{not} violate the CQS principle.
	All of the \textit{get} methods (e.g., \texttt{getID},
	\texttt{getPlace}, \texttt{getBankName}) return references to the
	corresponding instance variables and do nothing more. While the
    command	methods (e.g., \texttt{switchOn}, \texttt{switchOff},
	\texttt{performStartup}, modify the object state, but \texttt{performShutdown}) return nothing (\texttt{void} type).
		
	\item Consider the precondition of method subtract in class Money:
	public void subtract(Money amountToSubtract)
	\begin{enumerate}
	    \item The \texttt{this.cents - amountToSubtract.cents} $\geq$ 0 precondition of the \texttt{subtract} method
	    is a demanding precondition because the responsibility
	    to satisfy it is deferred to the client. If the client
	    does not satisfy it, the \texttt{cents} variable will
	    be negative which may produce incorrect behavior
	    depending on the application.\\
	    The precondition is reasonable and available because
	    the client need only call the \texttt{Money.lessEqual}
	    method before invoking \texttt{subtract} to determine
	    whether the precondition is satisifed.
	    
	    \item The \texttt{CashDispenser.dispenseCash} client
	    method does not check the \texttt{subtract} precondition
	    but instead defers it to its own precondition that
	    \texttt{amount} $\leq$ \texttt{cashOnHand}, as does
	    the \texttt{Simulation.dispenseCash} method. The
	    \texttt{SimulatedBank.withdrawal} method checks the
	    precondition and returns a \texttt{Failure} state if
	    it is violated, as does the \texttt{transfer} method.
	    The \texttt{Withdrawal.completeTransaction} method calls
	    \texttt{CashDispenser.dispenseCash} without checking
	    the precondition, so the possibility of a violation
	    exists.
	\end{enumerate}
	
	\item 
	\begin{enumerate}
		\item For an object of ATM class, is it possible that \texttt{switchOn} is false and
		\texttt{state=SERVING\_CUSTOMER\_STATE} is true? 
	    \item For an object of \texttt{Money} class, is it possible that this.cents<0?
    \end{enumerate} 
    	
    \item Is the class hierarchy of Transaction, Withdrawal, Transfer, Deposit, and Inquiry a good application of inheritance? Justify your answer.

\end{enumerate}

\end{document}
